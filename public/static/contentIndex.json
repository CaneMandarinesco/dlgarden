{"2024-01-11":{"title":"2024-01-11","links":[],"tags":[],"content":""},"art":{"title":"art","links":[],"tags":[],"content":"musica che vi consiglio (qvc) §\n\nLovely Sewer - Yves Tumor\nTHE DEATH OF PEACE OF MIND - Bad Omens\nTake Me Back To Eden - Sleep Token\nIn Rainbows - Radiohead\nBallon d’Or - Gem, Nayt\nHearts / Wires - Deftones\nRomanticist - Yves Tumor\nMisantropo a senso unico - Cripple Bastards\nMURUBURZUM - Ozone Dehumanizer\n\nfilm che vi consiglio :) §\n\neternal sunshine of the spotless mind (ci sta jim carrey, mio padre)\nthe truman show\nedward mani di forbice\nil castello errante di howl\n\nfumetti che vi consiglio §\n\nbunanotte punpun\nchainsaw man\n"},"bio":{"title":"bio","links":[],"tags":[],"content":"\nD. L., studio informatica a tor vergata (rm).\narch user (btw)\nnella vita oltre a fare l’universitario basic, sono un batterista, mi piace il metal.\nsono un fan di nayt.\nogni tanto leggo manga/guardo film/gioco.\nogni tanto esco con gli amici.\n\nlink §\n\ninstagram/threads: davide___luci\ngithub: CaneMandarinesco\n\nhardware §\nlaptop §\n\nT480s (comprato su ebay a 190 eur.)\nEndeavourOS con Hyprland\nintel i5-8350U, processore caruccio che non mi da problemi su arch\n16gb ram / 256gb ssd\n"},"diario":{"title":"diario","links":[],"tags":[],"content":"11/01/2023 §\nlife is ok…"},"index":{"title":"index","links":["bio","diario","art","lezioni-e-appunti/programmazione-dei-calcolatori","lezioni-e-appunti/analisi-1"],"tags":[],"content":"\nse vuoi sapere qualcosa su di me, ecco la mia bio\nil mio diario\nart\n\nappunti §\n\nprogrammazione dei calcolatori (python/c, prof. G. Rossi)\nanalisi 1 (prof. R. Tauraso)\nlogica e reti logiche  (prof. F. Pasquale)\nmatematica discreta (prof. F. Brenti)\n"},"lezioni-e-appunti/analisi-1":{"title":"analisi 1","links":[],"tags":[],"content":"materiale didattico\n\nlimiti notevoli\nderivate\nprimitive\n\nargomenti §\n\nproprieta dei numeri\nfunzioni, grafici e operazioni sui grafici\ncoefficiente binomiale e fattoriale\nmaggiorante e minorante, massimo e minimo, estremo superiore e inferiore di un insieme\nassioma di completezza\nlimite di una successione\nproprieta dei limiti\nlimiti notevoli\ncalcolo dei limiti\nintorni di un punto\nlimiti di funzioni\nderivata, retta tangente\nregole di derivazione\nderivate di funzioni elementari\npunti di massimo e minimo\nderivata II: concavita e convessita di f\npunto di flesso\npunti di discontinuita/non derivabilita\npolinomio di taylor\nalgebra o-piccoli\nmetodo di esaustione-compressione\ndef. di integrale: riemann-darboux\nproprieta funzioni integrabili\ndef. di primitiva\ntecniche di integrazione\nserie numeriche\nnumeri complessi\nproblema di cauchy\n\nteoremi e dimostrazioni §\n\n(​2) non e’ reale\ndisuguaglianza di bernoulli\npotenza di un binomio\ndimostrazioni proprieta’ dei limiti\nteorema degli zeri\nlimx→0​xsin(x)​=1\nteorema dei valori intermedi\nteorema di fermat sui punti stazionari\nteorema di bolzano-weierstrass\nteorema di weierstrass\nteorema di lagrande (o del valor medio)\nteorema di cauchy\nteorema de l’hopital\n\nlimiti notevoli §\n\nlimx→∞​(1+x1​)x=e\nlimx→∞​(1+xk​)x=ek\nlimx→0​(1+x)x1​=e\nlimx→0​xln(1+x)​=1\nla 4 deriva da questa:   limx→0​xloga​(1+x)​=ln(a)1​\nlimx→0​xex+1​=1\nlimx→0​xax+1​=ln(a)\nlimx→0​x(1+x)c−1​=c\nlimx→0​xsin(x)​=1\nlimx→0​x21−cos(x)​=21​\n\nderivate §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nf(x)dxdf​a0axaxaaxa−1ln(x)x1​sin(x)cos(x)cos(x)−sin(x)tan(x)cos2(x)1​arcsin(x)1−x2​1​arccos(x)1+x2​1​arctan(x)1+x21​\nprimitive §\ndef: ∀x,f(x)=F‘(x)\nossia la derivata di F(x) e’ uguale a f(x)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nf(x)F(x)xaa+1xa+1​x1​ln∥x∥"},"lezioni-e-appunti/programmazione-dei-calcolatori":{"title":"programmazione dei calcolatori","links":["lezioni-e-appunti/programmazione-dei-calcolatori/p.d.c.-lez-23---Introduzione-a-C","lezioni-e-appunti/programmazione-dei-calcolatori/p.d.c.-lez-24","lezioni-e-appunti/programmazione-dei-calcolatori/p.d.c.-lez-35"],"tags":[],"content":"materiale didattico\nargomenti per lezione §\n\nlinguaggio C, main(), viariabili, printf(), assegnazione\ncicli while e for, if...else, direttiva include e librerie\narray, sizeof(), puntatori\noperatori * e &amp;, complessita indicizzazione, allocazione dinamica con malloc()\nstruct, copia, typedef, implementazione di strutture come liste\ntipo sequenza, append(), pop(). free()\nrealloc() per ottimizzazione, tipo char e stringhe in c\napprofondimento funzioni di allocazione memoria, NULL. casting implicito e esplicito, libreria string, argomenti linea di comando\nconvesione str -&gt; int. sscanf(), argomenti per riferimento, liste concatenate: accesso diretto/sequenziale\nstrcmp(), definizione di nodo\nda aggiornare…\n\ncodice delle lezioni commentato §\n\np.d.c. lez 23 - Introduzione a C\np.d.c. lez 24\np.d.c. lez 35\n"},"lezioni-e-appunti/programmazione-dei-calcolatori/p.d.c.-lez-23---Introduzione-a-C":{"title":"p.d.c. lez 23 - Introduzione a C","links":[],"tags":[],"content":"struttura del file §\n#include &lt;stdio.h&gt; // include la libreria standard, contiene le funzioni piu comuni\n \nfloat abs_val( float );     // prototipo di funzione: vengono definiti solo i tipi delle variabili\nfloat radice2( float x );   // non e&#039; un prototipo, e&#039; stato definito il nome del tipo float ma deve ancora essere implementata\n                            // ricorda: le funzioni prima di essere chiamate devono essere almeno definite!\n \nvoid main(){\n  // punto di entrata per l&#039;esecuzione del codice.\n}\nmain §\noperazioni di assegnazione, divisione intera, e printf §\nvoid main(){\n\tint n = 5;          // int -&gt; integer, numeri interi\n\tfloat pi = 3.14;    // float -&gt; numeri con la virgola\n\t\n\t// sintassi per commentare una singola riga \n\t/*\n        sintassi per un commento su piu righe\n    */\n\t\n\tn = n/2;            // 5/2 = 2, divisione tra interi, ritorna un intero\n\tpi = (n+1)/2;       // 3/2=1 divisione tra interi, ritorna un intero\n                      // 1 viene automaticamente convertito in float: 1.000000, perche&#039; pi e&#039; tipo float\n  printf(&quot;n = %d, pi = %f\\n&quot;, n, pi);\t\nprintf(format, ...): stampa del testo sul terminale\n\nformat -&gt; testo da stampare, formattato secondo gli specificatori\n... -&gt; lista di oggetti da sostituire agli specificatori\n%d -&gt; indica che verra’ sostituito con un intero (int)\n%f -&gt; indica che verra’ sostituito con un numero con la virgola (float)\n\\n -&gt; carattere speciale, indica al terminale che bisogna andare a capo.\n\n\tpi = (n+1)/2.0;         // divisione tra intero e float, non segue le regole della divisione tra interi!\n                            // ritorna un float\n\tprintf(&quot;n = %d, pi = %f\\n&quot;, n, pi);\n\t\n\tpi = (1.0*(n+1))/2;     // viene calcolato prima n+1, che e&#039; un intero\n                            // viene calcolato poi 1.0*(n+1), che e&#039; un float\n                            // [1.0*(n+1)]/2 restituisce un float\n \n  printf(&quot;n = %d, pi = %f\\n&quot;, n, pi);\n\t \n  // la funzione: radice2 e&#039; stata dichiarata prima del main(), quindi puo&#039; essere chiamata\n  // il compilatore pensera&#039; a capire dove e&#039; stata definita, in questo caso dopo il main()\n\tprintf(&quot;La radice di %f = %f\\n&quot;, 2.0, radice2(2));\n\t \ncicli while e for §\n  int i = 2;\n  while ( i &lt; 20 ){   // traduzione letterale: mentre i e&#039; minore di 20 esegui: { ... }\n      printf(&quot;La radice di %d = %f\\n&quot;, i, radice2(i));\n      i++;            // equivalente a i += 1\n  }\n                      // il ciclo viene eseguito finche&#039; i &lt; 20\n                      // quando i = 20 l&#039;esecuzione del ciclo viene interrotta\n  \n  \n  for ( int j = 2; j &lt; 20; j++ ){ \n                      // traduzione letterale: per j = 2, finche&#039; j &lt; 20 esegui { ... }, poi fai j++\n      printf(&quot;La radice di %d = %f\\n&quot;, j, radice2(j));\n  }\n                      // il ciclo viene eseguito 20-1 volte, quando j=19 viene eseguito il codice nelle parentesi \n                      // poi alla fine viene aggiornato il valore di j che rende falsa j&lt;20\n  \n}\n\noperazioni relazionali: ==, &lt;=, &gt;=, !=\noperatori logici: &amp;&amp; equivale a and in python, !! equivale a or in python.\n"},"lezioni-e-appunti/programmazione-dei-calcolatori/p.d.c.-lez-24":{"title":"p.d.c. lez 24","links":[],"tags":[],"content":"struttura del file §\n#include &lt;stdio.h&gt;\n \nint somma(int [], int );\nint *somme_parziali(int [], int);\n \nint N = 12;  // variabile globale, qualsiasi funzione all&#039;interno di questo file puo&#039; usarla\n             // invece una funzione definita dentro main(), non puo&#039; essere usata in somma\n \nint main(){\n    ...\n}\nmain §\nint main(){\n\tint n;\n\tint a[12]; // array di 12 interi, vanno dalla posizione 0 fino alla posizione 11\n\tint b[] = {50, 1, 4, 9, 61}; // array di 5 interi\n\tint c[10] = {3, 2, 10}; // array di 10 interi, i primi 3 sono {3, 2, 10}\n\tint m[1000] = {0};\n\t// int x[n]; dove n e&#039; una variabile. questo e&#039; un errore perche&#039; il compilatore deve sapere precisamente quanta memoria deve allocare per un array, non si puo&#039; usare una variabile per definire la lunghezza di un array, bisogna usare un valore costante nel tempo (per esempio i numeri)\n\tint i; // quando una variabile viene inizializzata, le viene assegnato un valore randomico (che dipende dall&#039;indirizzo di memoria in cui si trova la variabile)\n\tint na = sizeof(a)/sizeof(int); // questo e&#039; un modo per ottenere il numero di elementi in un array, dividiamo la grandezza in byte di &#039;a&#039; per la grandezza di ogni singolo intero (ovvero ogni elemento di a)\n\t\n\tprintf(&quot;size(a) = %d\\n&quot;, sizeof(a));\n\t\n    // possiamo usare il ciclo for per scorrere tutti gli elementi di una lista\n\t// assegna per ogni valore di a il valore: i*i+1\n    for(i = 0; i &lt; na; i++){\n\t\ta[i] = i*i+1;\n\t}\n\t\n\tprintf(&quot;a\\n&quot;);\n \n\t// stampa ogni valore di a\n\tfor(i = 0; i &lt; na; i++){\n\t\tprintf(&quot;%d\\n&quot;, a[i]);\n\t}\n\t\n\tprintf(&quot;b\\n&quot;);\n\t\n\tfor(i = 0; i &lt; 5; i++){\n\t\tprintf(&quot;%d\\n&quot;, b[i]);\n\t}\n\t\n\tprintf(&quot;c\\n&quot;);\n\t\n\tfor(i = 0; i &lt; 10; i++){\n\t\tprintf(&quot;%d\\n&quot;, c[i]);\n\t}\n\t\n    // richiama la funzione somma\n\tprintf(&quot;somma(a) = %d\\n&quot;, somma(a, na));\n \n \n\tint *somme = somme_parziali(a, nx\\a);\n\t\n\tfor(i = 0; i &lt; na; i++){\n\t\tprintf(&quot;%d\\n&quot;, somme[i]);\n\t}\n\t\n}\nfunzioni somma §\nint somma(int x[], int n){\n    // int somma(int x[], int n)\n    // x: int[] -&gt; array di elementi da sommare\n    // n: int -&gt; numero di elementi di x\n \n    // n = sizeof(x)/sizeof(int); non da il risultato giusto\n    // il compilatore non sa quanti elementi ci sono in x, perche&#039; il suo tipo e&#039; incompleto in quanto manca la lunghezza dell&#039;array\n    // il tipo di x si dice incompleto perche&#039; a int x[] manca la lunghezza dell&#039;array\n \n\tint somma = 0;\n\t\n    // sizeof(x) in questo caso e&#039; equivalente a scrivere sizeof(int *x)\n\tprintf(&quot;sizeof(x) = %d\\n&quot;, sizeof(x));\n\t\n\tfor(int  i = 0; i &lt; n; i++){\n\t\tsomma += x[i];\n\t}\n\t\n\treturn somma;\n}\n \n \n// versione errata della funzione\nint somma2(int x[]){\n\tint somma = 0;\n\t\n\t//int na = sizeof(x)/sizeof(int);\n\t\n\tprintf(&quot;sizeof(x) = %d\\n&quot;, sizeof(x));\n\t\n\tfor(int  i = 0; i &lt; N; i++){\n\t\tsomma += x[i];\n\t}\n\t\n\treturn somma;\n}\n \nint *somme_parziali(int x[], int n){\n\t/*\n\t * ritorna un int s[n] tale che s[i] = x[0]+x[1]+...+x[i]\n     * ritorna un array s dove ogni elemento s[i] e&#039; la somma di di tutti gli elementi di x fino all&#039;elemento numero i\n     */\n    // crea un array lungo come x\n    int i, s[n], somme = 0;\n    \n    for( i = 0; i &lt; n; i++){\n        somme += x[i];\n        s[i] = somme;\n    }\n    \n    return s; // non va bene, ritorna l&#039;indirizzo di una variabile locale\n}"},"lezioni-e-appunti/programmazione-dei-calcolatori/p.d.c.-lez-35":{"title":"p.d.c. lez 35","links":[],"tags":[],"content":"struttura del file §\nunion item {\n    int val_i;\n    float val_f;\n    char *val_s;\n}\ntypedef union item item;\n// dentro a item, la stessa regione di memoria e&#039; condivisa tra val_i, val_f e val_s\n \nstruct object {\n    char type; // &#039;I&#039; -&gt; Intero, &#039;F&#039; -&gt; Float, &#039;S&#039; -&gt; *char\n    item u;\n}\ntypedef struct object object;\n \n/* converti l&#039;oggetto al tipo giusto per rappresentarlo */\nobject parse(char*);\n \n/*controlla il tipo dell&#039;item dentro a object e stampa il valore */\nvoid print(object);\n \n/* controlla se la stringa s contiene dei punti, in modo da capire se e&#039; un float */\nint cercapunto(char* s);\n \nint main(int argc, char** argv){\n    /*...*/\n}\n// implementazione"},"obsidian":{"title":"obsidian","links":[],"tags":[],"content":"\nsoftware per scrivere note\npensato per visualizzare e gestire i collegamenti tra note\ntanti temi customizzabili!\n\nmetodi per organizzare le note §\n\nMOC (Maps of content)\nPARA\nZettelkasten\n\ncose utili §\n\nhttps://obsidian.rocks/save-articles-to-obsidian-five-different-methods/\nusa i tag\nespandi la tab a destra (cliccando expand tab in altro a destra)\ntool per la ricerca: https://obsidian.rocks/obsidian-search-five-hidden-features/\n"}}